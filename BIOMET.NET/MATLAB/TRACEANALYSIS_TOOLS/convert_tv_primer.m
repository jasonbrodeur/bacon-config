%------------------------------------------------------------------------------------
% convert_tv_primer
%------------------------------------------------------------------------------------
% The purpose of convert_tv is to convert time vectors read from the biomet
% database to various time vector formats. This documents explains the conventions
% used in the database and for the various formats that may be needed. It then 
% explains the working of convert_tv in some detail and finally gives examples how to
% use it.
%------------------------------------------------------------------------------------
% Time vectors in the biomet data base
%
% The biomet data base contains a time time vector (*_tv) in each data subdirectory.
% The convention for these time vectors is that for each measurement in the traces 
% of a subdirectory the corresponding time vector contains the end points of each
% measurement interval in GMT. E.g. for halfhourly measurements and tv(x) = 15:30 the 
% corresponding measurement covers the interval 15:00 GMT to 15:30 GMT. As the 
% database always contains traces that cover a complete year the first element of a 
% trace (1 Jan 00:00) corresponds to the interval 31 Dec 23:30-1 Jan 00:00.
%
% The time vectors can be read from the database and converted to matlab time vector
% format using read_bor, e.g. as follows:
% pth = biomet_path('yyyy','pa','cl');
% tv_db = read_bor([pth 'bonet_new\bntn_tv'],8,[],[1998:2000]);
% See read_bor_primer.m for details on read_bor.
%
% The resulting matlab time vector can be of varying length, but the 'end of 
% measurement' and GMT convention mentioned above always applies to these vectors. 
%------------------------------------------------------------------------------------
% Time vectors in the database tool
%
% The plots generated by the database tool all give the data as Decimal day of year 
% (as used by Campbell, 1 Jan 12:00 noon = 1.5) and explicitly stat this in the label
% of the time axis. Also the data is plotted in local time because that way it is 
% easier to divide the diurnal course into its day and night part during visual 
% inspection
%
% HOWEVER, the exported matlab_tv that is generated while exporting the data follows
% the time vector convention described above.
%------------------------------------------------------------------------------------
% Time vector formats returned by convert_tv
%
% 'doy' - Decimal day of year as used by Campbell
% 1 Jan 12:00 noon = 1.5 
%
% 'jul' - Julian year day 
% 1 Jan 12:00 noon = 0.5 
%
% 'nod' - No of day 
% tv contains no of days (i.e. 24h intervals since tv(1))
%
% 'mtv' - Matlab format time vector
%  1 Jan 2000 12:00 noon = 730486.5 
%------------------------------------------------------------------------------------
% Conversion from GMT to local time
%
% If a GMT shift is given along with the time vector format the time vector is 
% converted to local time = GMT - GMT shift. For the BERMS sites the GMT shift is
% 6 hours, i.e. GMT 1 Jan 2000 00:00 corresponds to 31 Dec 1999 17:00 in the local
% time zone (CST ? - For PST (Campbell River site) the shift it 8 hours). 
% Accordingly, the corresponding 'doy' and 'jul' values are 365.75
% and 364.25. Hence a command like plot(doy,trace) leads to the first value being
% plotted at the end with a line running all across the plot. The return parameter
% year of convert_tv should be used to select only point from a certain year:
% plot(doy(find(year==2000)),trace(find(year==2000)))
%------------------------------------------------------------------------------------
% Changing the point given for the measurement interval
% 
% If the time vector should point to the beginning of the measurement interval the or
% any other point the fraction of the interval pointed to can be given to convert_tv.
% For a fraction of 0.5 of a halfhourly measuremtns an 'end of measurement' value of 
% GMT 1 Jan 2000 00:00 then corresponds to GMT 31 Dec 1999 23:45. This value is then
% GMT shifted and after that converted to the requested time format.
%------------------------------------------------------------------------------------
% Generating time vectors using convert_tv
%
% convert_tv may be used to generate time vectors according to the conventions 
% explained above. For this purpose the length of the desired 'measurement' interval
% can be provided to the function. The resulting values will be very close the ones 
% in the database. I.e.
%
% pth = biomet_pth([2000]),'pa');
% tv_db = read_bor([pth 'bonet_new\bntn_tv'],8,[],[2000]);
%
% and
% 
% tv_cv = convert_tv([datenum(2000,1,1),datenum(2000,12,31,23,59,0)]);
%
% will generate vector that agree to abs(tv_db - tv_cv) < 1.5e-5.
% BUT they are not identical. I wonder why ?
%------------------------------------------------------------------------------------
% convert_tv examples
%
% A time vector from the database can be read as follows:
pth = biomet_path('yyyy','pa','cl');
tv_db = read_bor([pth 'bonet_new\bntn_tv'],8,[],[1998:2000]);
% As example data we use HMP temperature from the top level
ta = read_bor([pth 'bonet_new\bntn.25'],[],[],[1998:2000]);
% ta needs a little cleaning
ind_ta = find(abs(ta) > 50); ta(ind_ta) = NaN;
 
% This function does what fr_get_doy does when used as follows:
% [tv_doy,year] = fr_get_doy(tv_db,1);
[tv_doy,year] = convert_tv(tv_db,'doy');
% [tv_doy,year] = fr_get_doy(tv_db,0);
[tv_jul,year] = convert_tv(tv_db,'jul');

% plotting of a single year works as follows
plot(tv_doy(find(year==2000)),ta(find(year==2000)));
% plotting by year works is also possible
ind = zeros(size(find(year==1999)),2);
for i = 1:2
   ind(:,i) = find(year==(1997+i));
end
plot(tv_doy(ind),ta(ind));

% A time vector is converted into local time as follows ...
gmt_shift_pa = 6;
[tv_mtv_local,year] = convert_tv(tv_db,'mtv',gmt_shift_pa);
% ... or as decimal DOY ...
[tv_doy_local,year] = convert_tv(tv_db,'doy',gmt_shift_pa);
% ... and if this is meant to poit to the beginning rather than
% the end of the measurement interval:
[tv_doy_local,year] = convert_tv(tv_db,'doy',gmt_shift_pa,'end');
% Finally the vector can also be pointed to the middle of the interval:
[tv_doy_local,year] = convert_tv(tv_db,'doy',gmt_shift_pa,0.5);

% Generating 5-day intervals from January 1998 to September 2000
[tv_5days,year] = convert_tv([datenum(1998,1,1),datenum(2000,9,1)],'mtv',[],0.5,5);
% But  tv_5days(1) in this case points to 29 Dec 1997, 12:00 noon as the inital 
% internal time vector is generated assuming that it points to the end of a five
% day interval, ending at 1 Jan 1998, 00:00. This could be avoided using GMT shift:
[tv_5days,year] = convert_tv([datenum(1998,1,1),datenum(2000,9,1)],'mtv',-0.5*2.5,0.5,5);
%------------------------------------------------------------------------------------
